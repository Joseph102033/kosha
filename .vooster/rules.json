{
  "rules": [
    {
      "type": "prd",
      "content": "# PRD — Safe OPS Studio (Cloudflare Free, TDD-first)\n\n## 0) Product framing\n- **One-liner**: Turn a short “Serious Accident Overview” into a one-page **OPS** brief with mapped laws, root causes, prevention checklist, and a shareable mail-ready page.\n- **Why now**: Demand for transparent, timely communication around serious accidents is increasing; teams need a fast, standardized brief that’s easy to send.\n- **Principles**: **Intuitive**, **Feasible-in-30 days**, **Privacy-first**, **Cloudflare Free tier–friendly**.\n\n---\n\n## 1) Outcomes (Success metrics)\n- **T1. First OPS in ≤10 minutes** from blank input to shareable link.\n- **T2. ≥70% law-suggestion hit-rate** from the initial ruleset (within scoped domains).\n- **T3. PDF render completes locally on common mobile/desktop in ≤5s** (client-side generation).\n- **T4. Email delivery API success rate ≥98%** (provider response 2xx).\n\n---\n\n## 2) Scope (MVP)\n- **Must**\n  - Public **Landing Page** with email subscription capture.\n  - **Admin OPS Builder**: input fields → generated **OPS preview** (summary, causes, prevention checklist, mapped laws, simple illustration or fallback diagram).\n  - **Law mapping (rules-first)** with small, editable keyword→reference table.\n  - **Share**: public, read-only web page per OPS + “Open as PDF” (client-side).\n  - **Send**: email a **link** to the public OPS page (no binary attachments).\n- **Should**\n  - Minimal ops history and resend logs.\n  - Weekly digest (manual trigger) using saved OPS items.\n- **Won’t (MVP)**\n  - Role-based ACL, SSO, binary storage of PDFs, heavy AI dependency, or complex analytics.\n\n---\n\n## 3) Users & Jobs\n- **Admin (investigator/analyst)**: Encode overview → review auto-sections → edit → publish → send link.\n- **Subscriber/Stakeholder**: Receive **latest OPS** in inbox; open on mobile; export to PDF locally.\n\n---\n\n## 4) Core flows (Given–When–Then acceptance)\n### 4.1 Landing subscription\n- **Given** the landing page,\n- **When** I enter a valid email and press **Subscribe**,\n- **Then** the system saves it and shows a “Subscribed” confirmation (and prevents duplicate re-subscription).\n\n### 4.2 Create OPS\n- **Given** the admin builder,\n- **When** I fill: date/time, location, agent object (optional), hazard object (optional), incident type, and free-text cause,\n- **Then** I see a generated one-page OPS with: summary (4–6 lines), direct/indirect causes, 6–10 prevention checks, law links, and a placeholder illustration.\n\n### 4.3 Law mapping\n- **Given** a saved ruleset,\n- **When** I provide incident type and objects,\n- **Then** I see ≥1 suggested law references with titles and URLs; I can remove or add more before publish.\n\n### 4.4 Publish & share\n- **Given** a valid OPS,\n- **When** I click **Publish**,\n- **Then** a public, read-only URL is created that renders the OPS (no admin controls).\n\n### 4.5 PDF (client-side)\n- **Given** the public OPS page,\n- **When** I click **Download PDF**,\n- **Then** a single-page PDF is generated locally (same layout, embedded fonts).\n\n### 4.6 Email send\n- **Given** the publish modal,\n- **When** I select recipients (typed or from subscribers) and press **Send**,\n- **Then** the email provider returns 2xx and the UI shows “Sent” with a delivery log entry.\n\n---\n\n## 5) Non-functional (Cloudflare Free conscious)\n- **Hosting**: Pages (static UI, public OPS rendering) + Workers (small APIs).\n- **Storage**: D1 for minimal relational data; KV for tiny caches; no binary file storage in MVP.\n- **Cost guardrails**: Client-side PDF/illustration fallback, caching of read-only public OPS, and a rules-first law engine to minimize expensive AI calls.\n- **Privacy**: No personal names or images required; OPS public pages avoid sensitive identifiers; admin-only edit.\n\n---\n\n## 6) Risks & mitigations\n- **Law accuracy**: Start with a small curated ruleset; every auto insertion requires a manual “Reviewed” checkbox before publish.\n- **Email deliverability**: Use a reputable REST email API; link-only (no attachments) reduces size/spam risk.\n- **Illustration ethics**: Default to iconographic diagram components; allow opt-in AI render with neutral style and strict anonymization.\n\n---\n\n## 7) Milestones (TDD-driven)\n- **M1 (Week 1)**: Landing + subscription API; OPS input form skeleton; first end-to-end “create → preview” red/green tests passing.\n- **M2 (Week 2)**: Law rules engine; public read-only page; core unit/integration tests green.\n- **M3 (Week 3)**: Email send (link-only) + delivery log; client-side PDF; e2e smoke tests green.\n- **M4 (Week 4)**: Polish, a11y, mobile QA; seed 20–30 law rules; demo pack ready.\n\n\n# TRD — Safe OPS Studio (Cloudflare Free, TDD-first)\n\n## 0) Architecture\n- **Frontend**: Next.js (Pages or App Router) + Tailwind + shadcn/ui.\n- **Backend**: Cloudflare **Workers** (HTTP JSON APIs), **D1** (SQLite) for data, **KV** for small caches.\n- **Email**: REST transactional provider (e.g., Resend/Mailgun/SendGrid) via HTTPS (no SMTP).\n- **Render**: Client-side PDF (html2pdf / browser print), public OPS page is SSR/SSG friendly.\n- **Illustration**: Optional AI image API (limited calls) → else SVG diagram fallback.\n\n---\n\n## 1) Data model (D1, minimal)\n- **subscribers**(id, email unique, status[pending|active|unsub], created_at)\n- **ops_documents**(id, title, incident_date, location, agent_object, hazard_object, incident_type, incident_cause, ops_json, created_by, created_at)\n  - `ops_json` includes: summary, causes{direct[], indirect[]}, checklist[], laws[{title,url}], image_meta (optional)\n- **deliveries**(id, ops_id, to_email, provider_msg_id, status[queued|sent|failed], sent_at)\n- **law_rules**(id, keyword, law_title, url)\n\n---\n\n## 2) APIs (Workers — JSON over HTTPS)\n- `POST /api/subscribe` → {ok}\n- `GET  /api/news?limit=N` → recent OPS titles (for landing list)\n- `POST /api/ops/generate` body: incident fields → returns draft `ops_json` (rules-first, AI optional)\n- `POST /api/ops/save` body: draft → persists, returns `{id, public_url}`\n- `GET  /api/ops/:id` (admin) → full JSON\n- `GET  /p/:slug` (public) → static/SSR page rendering `ops_json` (no admin controls)\n- `POST /api/send` body: `{ops_id, to[]}` → fan-out to email API, store results\n- `POST /api/law/rules` (admin) → CRUD for rules\n\n**Auth**: Admin routes protected via a simple Access Key in headers or one-time magic links (in Workers).\n\n---\n\n## 3) TDD plan — test suites (red → green → refactor)\n### 3.1 Unit tests (Miniflare/Workerd)\n- **Rules engine**\n  - Given inputs (“fall”, “openings”, “guardrail”), Then at least one law link is returned.\n  - No duplication: same rule fires once.\n- **OPS composer**\n  - Summary max 6 lines; checklist 6–10 items; JSON schema validation.\n\n### 3.2 Integration tests (Workers + D1)\n- **Subscribe**\n  - Creates unique record; duplicate returns idempotent success.\n- **Save OPS**\n  - Persists `ops_json`; returns public slug; GET `/p/:slug` renders required sections.\n- **Send**\n  - Mocks provider (HTTP 2xx) → writes `deliveries` with status=sent.\n\n### 3.3 E2E tests (Pages + Playwright)\n- **Landing flow**: subscribe and see confirmation.\n- **Admin flow**: create OPS → preview → publish → open public URL → click PDF (client-side) and see file generated.\n- **Email flow**: trigger send, UI shows “Sent”, and `deliveries` updated.\n\n---\n\n## 4) Implementation notes (Cloudflare Free conscious)\n- **No binary storage** in MVP: email sends **links**; PDF is generated client-side on demand.\n- **Caching**: KV cache for public OPS JSON (immutable after publish) to reduce D1 reads.\n- **LLM usage**: keep **optional**. Start rules-first; if enabled, call model API with short prompts; rate-limit in Worker.\n- **Secrets**: Email API keys stored in Worker environment (Secrets); never shipped to client.\n- **Fonts**: Use system fonts or embed a small open font subset for PDF consistency.\n\n---\n\n## 5) UI composition\n- **Landing**: headline, single email field, latest 3 OPS cards (from D1), footer contact line.\n- **Admin Builder**: left = input fields; right = live OPS preview with tabs (Summary / Causes / Checklist / Laws / Illustration).\n- **Public OPS**: clean A4 layout, print/PDF button, link to sources (law URLs).\n\n---\n\n## 6) Accessibility & mobile\n- Color-contrast AA+, keyboard focus rings, semantic landmarks, mobile-first breakpoints; print CSS for A4.\n\n---\n\n## 7) CI/CD\n- GitHub → Cloudflare Pages (Preview → Production).\n- Workers: wrangler deploy; run tests on every PR; block merge on failing tests.\n\n---\n\n## 8) Rollout plan (week-by-week with tests)\n- **Week 1**: Landing + subscribe API + OPS form scaffold; unit tests for rules/composer.\n- **Week 2**: Public page + D1 persistence + integration tests; initial 20–30 law rules seeded.\n- **Week 3**: Email API wiring + delivery logs + e2e smoke; client-side PDF button solid.\n- **Week 4**: A11y, print polish, mobile QA; test data set (3 sample OPS) and demo script.\n\n---\n\n## 9) Definition of Done (MVP)\n- All unit, integration, and e2e tests **green** in CI.\n- Create→Publish→Share→Open→PDF works on Chrome/Edge/Safari (desktop & mobile).\n- Seeded law rules produce at least one hit for each of the 3 demo scenarios.\n- Zero PII leak in public pages; secrets never exposed.\n\n---\n\n## 10) Future (post-MVP)\n- Role-based auth, richer rule editor, AI law search with citations, image upload with server-side redaction, weekly digest automation.\n",
      "writedAt": "2025-10-08T11:06:16.425Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**  \n  Safe OPS Studio delivers a one-page OPS brief from a short accident overview. The solution uses Cloudflare Free (Pages + Workers + D1 + KV), a Next.js frontend, TDD workflows, and client-side PDF generation to meet 30-day feasibility and privacy-first principles.\n- **Core Technology Stack**  \n  Next.js (React) + Tailwind + shadcn/ui for UI; Cloudflare Workers for API; D1 (SQLite) for relational data; KV for caching; REST email API (Resend/Mailgun).\n- **Key Technical Objectives**  \n  • First OPS in ≤10 min end-to-end  \n  • ≥70% law-suggestion hit-rate from curated rules  \n  • Client-side PDF render ≤5 s on common devices  \n  • Email API success ≥98%\n- **Critical Technical Assumptions**  \n  • OPS rules engine (keyword→law) is primary; optional AI supplement  \n  • No binary storage in MVP; client-side PDF only  \n  • Admin authentication via simple access key or magic link  \n  • Cloudflare Free limits guide architecture (Pages + Workers, D1 + KV)\n\n## 2. Tech Stack\n\n| Category           | Technology / Library      | Reasoning                                                         |\n| ------------------ | ------------------------- | ----------------------------------------------------------------- |\n| Frontend Framework | Next.js                   | SSR/SSG support, integration with Cloudflare Pages, developer DX  |\n| UI Styling         | Tailwind CSS + shadcn/ui  | Utility-first, rapid UI composition, accessible components        |\n| API Layer          | Cloudflare Workers        | Free tier HTTP APIs, minimal cold start, edge proximity          |\n| Relational Store   | D1 (SQLite)               | Free, serverless, relational for subscribers, OPS, deliveries     |\n| Cache Store        | Cloudflare KV             | Low-latency immutable caching for public OPS JSON                 |\n| Email Delivery     | Resend (or Mailgun)       | Simple REST API, high deliverability, free/low-cost tiers         |\n| PDF Generation     | html2pdf.js               | Client-side, no server costs, fast single-page PDF                |\n| Testing Framework  | Jest + Miniflare          | Worker unit tests, D1 integration mocks                          |\n| E2E Testing        | Playwright                | Cross-browser flows, mobile emulation                             |\n| Deployment         | Cloudflare Pages + Wrangler CLI | GitHub integration, automated preview & production deployments     |\n\n## 3. System Architecture Design\n\n### Top-Level Building Blocks\n- **Static/UI Hosting**  \n  - Next.js Pages deployed on Cloudflare Pages  \n  - Public OPS pages served via SSG/SSR  \n- **API Layer**  \n  - Cloudflare Workers expose JSON endpoints (/api/subscribe, /api/ops, /api/send, /api/law)  \n  - Authentication via access key header  \n- **Data Stores**  \n  - D1 (SQLite) for subscribers, OPS docs, law rules, deliveries  \n  - KV for caching published OPS JSON  \n- **Email Service**  \n  - REST calls to transactional email provider  \n- **Client-Side Utilities**  \n  - html2pdf.js for PDF export  \n  - SVG fallback illustration library\n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n  A[Browser UI] --> B[Cloudflare Pages]\n  A --> C[Cloudflare Workers]\n  C --> D[D1 Database]\n  C --> E[KV Cache]\n  C --> F[Email API]\n  A --> G[Client-Side PDF Generator]\n```\n\n- Browser UI fetches static assets from Cloudflare Pages.  \n- Browser UI invokes Workers for subscription, OPS creation, publishing, sending.  \n- Workers read/write relational data to D1 and cache public OPS JSON in KV.  \n- Workers call external Email API for sending link-only emails.  \n- Browser triggers html2pdf.js for client-side PDF generation.\n\n### Code Organization & Convention\n\n**Domain-Driven Organization Strategy**  \n- **Domain Separation**:  \n  - subscription, ops, law, delivery  \n- **Layer-Based Architecture**:  \n  - presentation (Next.js pages/components)  \n  - service (Workers handlers)  \n  - data access (D1/KV wrappers)  \n- **Feature-Based Modules**:  \n  - each domain in its own folder with related handlers, models, tests  \n- **Shared Components**:  \n  - UI atoms, types, utils, HTTP client, email client\n\n**Universal File & Folder Structure**\n```\n/\n├── apps\n│   ├── web                     # Next.js frontend\n│   │   ├── pages\n│   │   ├── components\n│   │   ├── styles\n│   │   └── tests\n│   └── workers                 # Cloudflare Workers\n│       ├── src\n│       │   ├── subscriptions\n│       │   ├── ops\n│       │   ├── law\n│       │   ├── delivery\n│       │   ├── db\n│       │   ├── cache\n│       │   └── utils\n│       └── tests\n├── scripts                      # DB migrations, seeding\n├── .github\n│   └── workflows                # CI/CD pipelines\n└── README.md\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**:  \n  JSON REST over HTTPS; Next.js fetch/xhr from Workers endpoints.\n- **Database Interaction**:  \n  Use D1’s built-in query interface; simple parameterized SQL or ORM-lite wrapper.\n- **External Service Integration**:  \n  Email API client wraps REST calls with retries; secrets in Worker env.\n- **Real-time Communication**:  \n  Not required; no WebSocket or SSE planned in MVP.\n- **Data Synchronization**:  \n  Immutable public OPS JSON cached in KV on publish; stale-safe for read.\n\n## 4. Performance & Optimization Strategy\n- Cache public OPS JSON in KV with TTL = ∞ (invalidate only on update) to minimize D1 reads.  \n- Bundle and Tree-shake Next.js output; enable gzip/Brotli on Pages.  \n- Lazy-load large UI components (illustration editor, settings) only when needed.  \n- Use client-side PDF library to offload rendering from server; inline small font subsets.\n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP Implementation)\n- Core Infrastructure: Cloudflare Pages + Workers + D1 + KV setup  \n- Essential Features: Landing subscription, OPS input & preview, law rules engine, publish/share  \n- Basic Security: Access key protection, input validation  \n- Development Setup: GitHub Actions for unit/integration tests, Wrangler CI  \n- Timeline: Week 1\n\n### Phase 2: Feature Enhancement\n- Advanced Features: Minimal ops history, resend logs, manual weekly digest trigger  \n- Performance Optimization: KV caching, HTTP response compression  \n- Enhanced Security: Rate-limiting on APIs, input sanitization  \n- Monitoring Implementation: Basic logs (Workers), error reporting (Sentry)  \n- Timeline: Week 2–3\n\n### Phase 3: Scaling & Optimization\n- Scalability Implementation: Optimize D1 queries, consider sharding rules if needed  \n- Advanced Integrations: Optional AI illustration API with rate-limits  \n- Enterprise Features: Role-based ACL, SSO (post-MVP)  \n- Compliance & Auditing: Audit logs for OPS changes and sends  \n- Timeline: Week 4\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n- **Law Accuracy**:  \n  • Risk: Poor keyword mapping yields low hit-rate  \n  • Mitigation: Manual review checkbox; seed curated rules, iterate weekly\n- **Performance Bottlenecks**:  \n  • Risk: D1 cold-start or high latency  \n  • Mitigation: Cache with KV; optimize SQL; cold starts limited on free tier\n- **Email Reliability**:  \n  • Risk: API outages or 4xx errors  \n  • Mitigation: Retry logic; delivery logs; fallback resend UI\n- **Client-side PDF Issues**:  \n  • Risk: Browser memory/timeouts on mobile  \n  • Mitigation: Simple layout; small asset footprint; test on target devices\n\n### Project Delivery Risks\n- **Timeline Risks**:  \n  • Risk: Overrun due to unplanned complexity  \n  • Mitigation: Strict MVP scope, weekly demos, TDD gating\n- **Resource Risks**:  \n  • Risk: Limited Cloudflare Free constraints  \n  • Mitigation: Optimize for free tier; avoid server-side PDF or heavy compute\n- **Quality Risks**:  \n  • Risk: Insufficient test coverage  \n  • Mitigation: Enforce unit/integration/e2e tests in CI before merge\n- **Deployment Risks**:  \n  • Risk: Env misconfiguration, secret leaks  \n  • Mitigation: Use Wrangler secrets, preview environments, branch protection\n\n",
      "writedAt": "2025-10-08T11:06:16.428Z"
    },
    {
      "type": "guideline",
      "content": "# Safe OPS Studio 코드 가이드라인\n\n## 1. 프로젝트 개요\n\nSafe OPS Studio는 짧은 사고 개요를 바탕으로 법률 매핑, 근본 원인, 예방 체크리스트를 포함하는 한 페이지짜리 OPS 브리프를 생성합니다. 이 프로젝트는 Cloudflare Free 티어(Pages, Workers, D1, KV)를 활용하며, Next.js 프론트엔드와 TDD(테스트 주도 개발) 워크플로우를 따릅니다. 클라이언트 측 PDF 생성 기능을 통해 30일 이내 구현 가능성 및 개인 정보 보호 원칙을 준수합니다.\n\n**주요 기술 스택:**\n*   **프론트엔드**: Next.js (React), Tailwind CSS, shadcn/ui\n*   **백엔드**: Cloudflare Workers (API), D1 (SQLite), KV (캐싱)\n*   **이메일 서비스**: Resend 또는 Mailgun (REST API)\n*   **PDF 생성**: html2pdf.js (클라이언트 측)\n*   **테스팅**: Jest, Miniflare, Playwright\n*   **배포**: Cloudflare Pages, Wrangler CLI\n\n**핵심 아키텍처 결정:**\n*   **서버리스 우선**: Cloudflare Workers를 활용한 경량 API 및 Cloudflare Pages를 통한 정적/SSR UI 호스팅.\n*   **클라이언트 측 오프로딩**: PDF 생성 및 일부 이미지 처리(SVG 폴백)를 클라이언트 측에서 처리하여 서버 비용 최소화.\n*   **데이터 스토리지 최적화**: D1(관계형 데이터)과 KV(불변 캐시)를 용도에 맞게 사용하여 Cloudflare Free 티어 제약 준수.\n*   **TDD 기반 개발**: 모든 기능 개발은 테스트 코드 작성을 선행하여 견고하고 유지보수 가능한 코드베이스 구축.\n\n## 2. 핵심 원칙\n\n1.  **명확성 및 가독성**: 모든 코드는 다른 개발자가 쉽게 이해하고 유지보수할 수 있도록 명확하고 일관성 있게 작성되어야 합니다.\n2.  **테스트 가능성**: 모든 기능은 단위, 통합, E2E 테스트가 용이하도록 설계 및 구현되어야 합니다.\n3.  **성능 최적화**: Cloudflare Free 티어의 제약을 인지하고, 비용 효율적이며 빠른 응답 시간을 보장하도록 코드를 최적화해야 합니다.\n4.  **보안 및 개인 정보 보호**: 사용자 데이터 및 시스템 보안을 최우선으로 고려하여 취약점이 없도록 코드를 작성해야 합니다.\n5.  **모듈화 및 재사용성**: 각 컴포넌트, 함수, 모듈은 단일 책임 원칙을 따르고 재사용 가능하도록 설계되어야 합니다.\n\n## 3. 언어별 가이드라인\n\n### 3.1. TypeScript (Next.js & Cloudflare Workers)\n\n*   **파일 및 디렉토리 구조**:\n    *   **MUST**: TRD에 명시된 `/apps/web` 및 `/apps/workers` 구조를 따르며, 각 도메인(subscription, ops, law, delivery)별로 폴더를 구성합니다.\n    *   **MUST**: 각 도메인 폴더 내에는 `handlers`, `models`, `services`, `utils`, `tests` 등 역할별 서브 폴더를 생성하여 관련 파일을 모읍니다.\n    *   **MUST**: Next.js `app` 라우터 대신 `pages` 라우터 구조를 사용합니다.\n    *   **MUST NOT**: 단일 파일에 여러 도메인의 로직을 혼합하여 작성합니다.\n\n    ```\n    // MUST: 올바른 디렉토리 구조 예시\n    // 각 도메인별로 책임이 명확하게 분리되어 있습니다.\n    apps/\n    └── workers/\n        └── src/\n            ├── ops/\n            │   ├── handlers.ts     // API 핸들러\n            │   ├── models.ts       // 데이터 모델 (타입 정의)\n            │   ├── services.ts     // 비즈니스 로직\n            │   └── tests/\n            │       └── ops.test.ts // 단위 테스트\n            ├── subscriptions/\n            │   ├── handlers.ts\n            │   └── ...\n            └── db/\n                └── schema.ts       // D1 스키마 정의\n    ```\n\n*   **타입 정의**:\n    *   **MUST**: 모든 변수, 함수 매개변수, 반환 값에 명확한 타입을 명시합니다. `any` 타입 사용은 엄격히 금지됩니다.\n    *   **MUST**: API 응답 및 요청 페이로드에 대한 인터페이스 또는 타입을 정의하여 일관성을 유지합니다.\n    *   **MUST**: D1 스키마와 일치하는 데이터 모델 타입을 정의하여 데이터 일관성을 확보합니다.\n\n    ```typescript\n    // MUST: 명확한 타입 정의 예시\n    // API 응답 및 D1 데이터 구조에 대한 타입 정의는 코드의 안정성을 높입니다.\n    interface OpsDocument {\n      id: string;\n      title: string;\n      incident_date: string;\n      location: string;\n      incident_type: 'fall' | 'fire' | 'chemical'; // 예시\n      ops_json: OpsContent;\n      created_at: Date;\n    }\n\n    interface OpsContent {\n      summary: string;\n      causes: { direct: string[]; indirect: string[] };\n      checklist: string[];\n      laws: { title: string; url: string }[];\n      image_meta?: { url: string; alt: string };\n    }\n\n    // MUST NOT: 'any' 타입 남용 예시\n    // 타입 추론을 방해하고 런타임 오류의 가능성을 높입니다.\n    function processData(data: any): any { /* ... */ }\n    ```\n\n*   **임포트/의존성 관리**:\n    *   **MUST**: 절대 경로 임포트(예: `@/components/Button`)를 사용하여 가독성을 높입니다.\n    *   **MUST**: 필요한 모듈만 임포트하고, 사용하지 않는 임포트는 제거합니다.\n    *   **MUST NOT**: 상대 경로 임포트(예: `../../../utils/helper`)를 깊게 사용하는 것을 피합니다.\n\n*   **에러 핸들링**:\n    *   **MUST**: API 핸들러 및 서비스 로직에서 발생할 수 있는 모든 예상 가능한 오류를 명확하게 처리합니다.\n    *   **MUST**: 사용자에게 의미 있는 에러 메시지를 반환하고, 내부 에러 정보는 로그로만 기록합니다.\n    *   **MUST**: Promise 기반 비동기 코드에서는 `try-catch` 블록 또는 `.catch()`를 사용하여 에러를 처리합니다.\n    *   **MUST**: Cloudflare Workers에서는 `Response` 객체와 적절한 HTTP 상태 코드(예: 400, 401, 404, 500)를 사용하여 에러를 반환합니다.\n\n    ```typescript\n    // MUST: 올바른 에러 핸들링 예시 (Cloudflare Worker)\n    // 사용자에게 의미 있는 에러 메시지와 적절한 HTTP 상태 코드를 반환합니다.\n    export async function handleSubscribe(request: Request): Promise<Response> {\n      try {\n        const { email } = await request.json();\n        if (!email || !isValidEmail(email)) {\n          return new Response(JSON.stringify({ error: '유효하지 않은 이메일 주소입니다.' }), { status: 400 });\n        }\n        // ... 구독 로직\n        return new Response(JSON.stringify({ message: '구독 성공' }), { status: 200 });\n      } catch (error) {\n        console.error('구독 처리 중 에러 발생:', error);\n        return new Response(JSON.stringify({ error: '서버 오류가 발생했습니다.' }), { status: 500 });\n      }\n    }\n\n    // MUST NOT: 에러를 무시하거나 일반적인 에러 메시지를 반환하는 예시\n    // 사용자에게 유용한 정보를 제공하지 못하고 디버깅을 어렵게 합니다.\n    async function dangerousFunction() {\n      try {\n        // ...\n      } catch (e) {\n        return new Response(JSON.stringify({ message: '에러 발생' }), { status: 500 }); // 구체적인 정보 없음\n      }\n    }\n    ```\n\n### 3.2. React (Next.js Frontend)\n\n*   **컴포넌트 구조**:\n    *   **MUST**: 단일 책임 원칙에 따라 컴포넌트를 작게 분리합니다.\n    *   **MUST**: 재사용 가능한 UI 요소는 `/components/ui`에, 특정 페이지에 종속된 컴포넌트는 해당 페이지 폴더 내에 위치시킵니다.\n    *   **MUST**: `props` 드릴링을 피하고, Context API 또는 상태 관리 라이브러리(필요시)를 고려합니다. (MVP에서는 복잡한 상태 관리 패턴 지양)\n\n*   **상태 관리**:\n    *   **MUST**: `useState`, `useReducer`와 같은 React 훅을 사용하여 컴포넌트 로컬 상태를 관리합니다.\n    *   **MUST**: 전역 상태가 필요한 경우, React Context API를 사용합니다.\n    *   **MUST NOT**: 복잡한 전역 상태 관리 라이브러리(예: Redux, Zustand)는 MVP 범위에서 도입하지 않습니다.\n\n    ```typescript\n    // MUST: React Context API를 사용한 전역 상태 관리 예시\n    // 필요한 경우에만 전역 상태를 사용하고, 그 외에는 컴포넌트 로컬 상태를 유지합니다.\n    // context/OpsContext.tsx\n    import React, { createContext, useContext, useState, ReactNode } from 'react';\n\n    interface OpsState {\n      draftOps: any | null;\n      setDraftOps: (ops: any) => void;\n    }\n\n    const OpsContext = createContext<OpsState | undefined>(undefined);\n\n    export const OpsProvider = ({ children }: { children: ReactNode }) => {\n      const [draftOps, setDraftOps] = useState<any | null>(null);\n      return (\n        <OpsContext.Provider value={{ draftOps, setDraftOps }}>\n          {children}\n        </OpsContext.Provider>\n      );\n    };\n\n    export const useOps = () => {\n      const context = useContext(OpsContext);\n      if (context === undefined) {\n        throw new Error('useOps must be used within an OpsProvider');\n      }\n      return context;\n    };\n\n    // MUST NOT: 복잡한 상태 관리 패턴을 불필요하게 도입하는 예시\n    // MVP 단계에서는 오버엔지니어링을 피합니다.\n    // import { createStore } from 'zustand'; // MVP에서는 사용하지 않습니다.\n    ```\n\n## 4. 코드 스타일 규칙\n\n### 4.1. MUST (필수 사항)\n\n*   **일관된 포맷팅**:\n    *   **규칙**: Prettier와 ESLint를 사용하여 코드 포맷팅 및 스타일을 자동화하고, 모든 개발자는 이 도구들을 프로젝트에 적용해야 합니다.\n    *   **이유**: 코드 가독성을 높이고, 코드 리뷰 시간을 단축하며, 팀 전체의 생산성을 향상시킵니다.\n*   **변수 및 함수명**:\n    *   **규칙**: 변수명은 `camelCase`를 사용하고, 상수는 `SCREAMING_SNAKE_CASE`를 사용합니다. 함수명은 동사로 시작하여 해당 함수의 동작을 명확히 설명합니다.\n    *   **이유**: 코드의 의미를 명확히 하고, 예측 가능성을 높입니다.\n    *   **예시**:\n        ```typescript\n        // MUST: 명확하고 일관된 명명 규칙\n        const incidentDate = new Date();\n        const MAX_OPS_SUMMARY_LINES = 6;\n        function getOpsDocumentById(id: string): OpsDocument | null { /* ... */ }\n        ```\n*   **주석**:\n    *   **규칙**: 복잡한 로직, 비즈니스 규칙, 또는 특정 디자인 결정에 대한 설명이 필요한 경우에만 주석을 작성합니다. JSDoc 스타일 주석을 사용하여 함수의 목적, 매개변수, 반환 값을 설명합니다.\n    *   **이유**: 불필요한 주석은 코드를 지저분하게 만들고, 오래된 주석은 오해를 유발할 수 있습니다. 잘 작성된 코드는 그 자체로 설명되어야 합니다.\n*   **비동기 처리**:\n    *   **규칙**: `async/await` 구문을 사용하여 비동기 코드를 작성합니다. 콜백 헬(callback hell)을 피하고, 가독성을 높입니다.\n    *   **이유**: 비동기 코드의 흐름을 동기 코드처럼 읽기 쉽게 만들어 디버깅 및 유지보수를 용이하게 합니다.\n*   **D1 쿼리**:\n    *   **규칙**: D1 쿼리 시 반드시 매개변수화된 쿼리를 사용합니다. SQL 인젝션 공격을 방지하기 위함입니다.\n    *   **이유**: 보안 취약점을 예방하고 데이터 무결성을 보장합니다.\n    *   **예시**:\n        ```typescript\n        // MUST: 매개변수화된 D1 쿼리 사용\n        // SQL 인젝션 공격을 방지하는 안전한 방법입니다.\n        async function getSubscriberByEmail(db: D1Database, email: string) {\n          const { results } = await db.prepare('SELECT * FROM subscribers WHERE email = ?')\n                                      .bind(email)\n                                      .all();\n          return results[0];\n        }\n\n        // MUST NOT: 문자열 연결을 통한 D1 쿼리 (SQL 인젝션 취약)\n        // const { results } = await db.prepare(`SELECT * FROM subscribers WHERE email = '${email}'`).all();\n        ```\n*   **환경 변수 관리**:\n    *   **규칙**: API 키, 비밀번호 등 민감한 정보는 환경 변수(`Worker environment variables`)에 저장하고, 클라이언트 측으로 노출되지 않도록 합니다.\n    *   **이유**: 보안을 강화하고, 환경별 설정을 유연하게 관리할 수 있습니다.\n\n### 4.2. MUST NOT (금지 사항)\n\n*   **거대 모듈/파일**:\n    *   **규칙**: 단일 파일에 너무 많은 책임과 로직을 포함하는 거대한 모듈을 만들지 않습니다.\n    *   **이유**: 파일의 크기가 커질수록 이해하기 어렵고, 특정 기능 수정 시 예상치 못한 부작용을 일으킬 수 있으며, 코드 재사용성을 저해합니다.\n*   **복잡한 상태 관리 패턴**:\n    *   **규칙**: MVP 단계에서 Redux, Zustand와 같은 복잡한 전역 상태 관리 라이브러리를 불필요하게 도입하지 않습니다.\n    *   **이유**: 프로젝트의 복잡도를 증가시키고, 학습 곡선을 높여 개발 속도를 저하시킬 수 있습니다. React Context API와 `useState`/`useReducer`로 충분합니다.\n*   **하드코딩된 값**:\n    *   **규칙**: 매직 넘버, 문자열 리터럴 등 반복되거나 변경될 가능성이 있는 값들을 코드 내에 하드코딩하지 않고, 상수로 정의하거나 설정 파일에서 관리합니다.\n    *   **이유**: 유지보수를 어렵게 하고, 오류 발생 가능성을 높입니다.\n*   **클라이언트 측 민감 정보 노출**:\n    *   **규칙**: API 키, 비밀번호 등 민감한 정보를 클라이언트 측 JavaScript 코드에 직접 포함하거나 환경 변수로 노출하지 않습니다.\n    *   **이유**: 보안 취약점의 주요 원인이 됩니다. 모든 민감 정보는 Cloudflare Workers 환경 변수에 저장하고 서버 측에서만 사용해야 합니다.\n*   **불필요한 외부 라이브러리**:\n    *   **규칙**: 프로젝트에 꼭 필요한 경우가 아니라면 새로운 외부 라이브러리 추가를 지양합니다.\n    *   **이유**: 번들 크기를 증가시키고, 잠재적인 보안 취약점을 도입할 수 있으며, 의존성 관리를 복잡하게 만듭니다.\n\n## 5. 아키텍처 패턴\n\n### 5.1. 컴포넌트/모듈 구조 가이드라인\n\n*   **단일 책임 원칙 (SRP)**: 각 컴포넌트나 모듈은 하나의 명확한 책임만을 갖도록 설계합니다.\n    *   예: `Button` 컴포넌트는 버튼 UI만 담당하고, `OpsForm` 컴포넌트는 OPS 생성 폼의 로직과 UI를 담당합니다.\n*   **재사용성**: UI 컴포넌트, 유틸리티 함수, 타입 정의 등은 여러 곳에서 재사용할 수 있도록 일반화하여 작성합니다.\n*   **도메인 기반 모듈화**: TRD에 명시된 대로 `subscriptions`, `ops`, `law`, `delivery`와 같은 도메인별로 코드를 모듈화하여 관리합니다.\n\n### 5.2. 데이터 흐름 패턴\n\n*   **단방향 데이터 흐름**: React 컴포넌트의 상태는 상위 컴포넌트에서 하위 컴포넌트로 `props`를 통해 전달되는 단방향 흐름을 따릅니다.\n*   **API를 통한 데이터 변경**: 클라이언트에서 서버의 데이터를 변경할 때는 항상 정의된 REST API 엔드포인트를 통해 요청을 보냅니다. 직접 D1 데이터베이스에 접근하는 것은 금지됩니다.\n*   **KV 캐싱 활용**: 공개된 OPS 문서(`ops_json`)와 같이 변경이 적고 자주 읽히는 데이터는 Cloudflare KV에 캐싱하여 D1 데이터베이스의 부하를 줄이고 응답 속도를 향상시킵니다.\n    *   **MUST**: KV에 저장되는 데이터는 불변(immutable)이어야 하며, 변경 시 새로운 키로 저장하거나 기존 키의 TTL을 업데이트하여 캐시를 무효화합니다.\n\n### 5.3. 상태 관리 컨벤션\n\n*   **로컬 상태 우선**: 대부분의 UI 상태는 `useState` 또는 `useReducer`를 사용하여 해당 컴포넌트 내에서 관리합니다.\n*   **공유 상태는 Context API**: 여러 컴포넌트에서 공유해야 하는 전역 상태(예: 로그인 사용자 정보, OPS 초안 데이터)는 React Context API를 사용하여 관리합니다.\n\n### 5.4. API 설계 표준 (Cloudflare Workers)\n\n*   **RESTful 원칙**: API 엔드포인트는 RESTful 원칙을 따르며, 리소스 기반으로 설계합니다.\n    *   예: `GET /api/ops/:id`, `POST /api/subscribe`\n*   **JSON 형식**: 모든 API 요청 및 응답은 JSON 형식을 사용합니다.\n*   **HTTP 상태 코드**: 적절한 HTTP 상태 코드(예: 200 OK, 201 Created, 400 Bad Request, 401 Unauthorized, 404 Not Found, 500 Internal Server Error)를 사용하여 API 호출 결과를 명확하게 전달합니다.\n*   **인증**: 관리자 API는 TRD에 명시된 대로 간단한 Access Key (헤더) 또는 일회성 매직 링크를 통해 인증합니다.\n*   **입력 유효성 검사**: 모든 API 요청의 입력 데이터는 서버 측에서 철저하게 유효성을 검사합니다.\n*   **로깅**: Workers에서 발생하는 중요한 이벤트(성공적인 요청, 에러, 외부 서비스 호출 등)는 `console.log`를 사용하여 기록합니다.\n\n    ```typescript\n    // MUST: RESTful API 설계 및 JSON 응답 예시\n    // 일관된 API 응답 구조를 유지합니다.\n    export async function getOpsDocument(request: Request, env: Env): Promise<Response> {\n      const url = new URL(request.url);\n      const id = url.pathname.split('/').pop();\n\n      if (!id) {\n        return new Response(JSON.stringify({ error: 'OPS ID가 필요합니다.' }), { status: 400 });\n      }\n\n      const { results } = await env.DB.prepare('SELECT * FROM ops_documents WHERE id = ?')\n                                      .bind(id)\n                                      .all();\n\n      if (!results || results.length === 0) {\n        return new Response(JSON.stringify({ error: 'OPS 문서를 찾을 수 없습니다.' }), { status: 404 });\n      }\n\n      return new Response(JSON.stringify(results[0]), {\n        headers: { 'Content-Type': 'application/json' },\n        status: 200,\n      });\n    }\n    ```",
      "writedAt": "2025-10-08T11:06:16.428Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-10-08T11:06:16.428Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-10-08T11:06:16.428Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-10-08T11:06:16.428Z"
    },
    {
      "type": "isms-p",
      "content": "\n# ISMS-P Based Secure Development Rules (v1.0)\n# This document defines the mandatory security rules for developers during code implementation.\n# Reference: Based on the Information Security Management System - Personal Information (ISMS-P) standard.\n\n## 1. Authentication & Authorization\n- **(A-1) User Identification and Authentication**\n  - **MUST**: Every user must be individually identifiable. The use of shared accounts is prohibited.\n  - **MUST**: Passwords MUST satisfy one of the following policies:\n    - (a) 8+ characters with a mix of letters, numbers, and special characters.\n    - (b) 10+ characters with a mix of letters and numbers.\n  - **MUST**: An account lockout policy MUST be implemented for failed login attempts (e.g., lock the account for 5 minutes after 5 consecutive failures).\n\n- **(A-2) Management of Authentication Credentials**\n  - **MUST**: Authentication credentials such as passwords MUST be stored using an adaptive hash function like **bcrypt, scrypt, or Argon2**. (Using SHA-256 alone is prohibited).\n\n- **(A-3) Privilege Management**\n  - **MUST**: Grant only the minimum necessary privileges for a role, following the **Principle of Least Privilege**.\n  - **MUST**: All actions of granting, changing, and revoking privileges MUST be logged.\n\n- **(A-4) Privileged Access Management**\n  - **MUST**: Administrative privileges (e.g., root, admin) MUST be granted to a minimum number of users, and the reason for using such accounts MUST be clearly logged.\n  - **SHOULD**: Administrative accounts SHOULD be separate from regular user accounts.\n\n## 2. Access Control\n- **(AC-1) System Access**\n  - **MUST**: Access to information systems by unauthorized users MUST be blocked.\n  - **MUST**: Access logs for critical systems MUST be retained for **at least one year**.\n\n- **(AC-2) Network Access**\n  - **MUST**: Public-facing services MUST be located in a **DMZ**, separate from the internal network.\n  - **MUST**: Firewalls MUST allow only the minimum necessary ports required for the service. (Prohibit \"allow all\" rules).\n\n## 3. Cryptography\n- **(C-1) Encryption of Sensitive Information**\n  - **MUST**: Legally defined sensitive information (e.g., national ID numbers, passport numbers, bank account numbers, credit card numbers) and passwords MUST be encrypted during storage and transmission.\n  - **MUST**: Use secure and vetted cryptographic algorithms such as **AES-256**.\n  - **MUST NOT**: Do not use homegrown or custom-developed cryptographic algorithms.\n\n- **(C-2) Cryptographic Key Management**\n  - **MUST NOT**: Do not hardcode cryptographic keys in source code, configuration files, or comments.\n  - **MUST**: Cryptographic keys MUST be managed securely using **environment variables** or a dedicated **Key Management System (KMS, HSM)**.\n  - **MUST**: Minimize access to keys and log all lifecycle management procedures, including generation, use, and destruction.\n\n## 4. Secure Development\n- **(D-1) Secure Design**\n  - **MUST**: Defense mechanisms against major vulnerabilities like the **OWASP Top 10** (e.g., SQL Injection, XSS, CSRF) MUST be incorporated during the design phase.\n\n- **(D-2) Secure Coding**\n  - **MUST**: Treat all external input (e.g., request parameters, headers, cookies) as untrusted. **Validation and sanitization** logic MUST always be applied.\n  - **MUST**: All SQL queries MUST use **parameterized queries (prepared statements)**. (Dynamic query string concatenation is prohibited).\n  - **MUST**: When handling errors, ensure that internal system details (e.g., stack traces, database information) are not exposed to the user.\n\n- **(D-3) Security Testing**\n  - **SHOULD**: Periodically scan for security vulnerabilities using static/dynamic analysis tools (**SAST/DAST**).\n\n## 5. Personal Information Handling\n- **(P-1) Collection and Use**\n  - **MUST**: Collect only the minimum personal information necessary to provide the service. The purpose of collection MUST be clearly disclosed to users, and consent must be obtained.\n  - **MUST NOT**: Do not process sensitive information (e.g., beliefs, ideology) or unique identification information without a legal basis or separate user consent.\n\n- **(P-2) Storage and Display**\n  - **MUST**: Personal information MUST be **masked** when displayed on screen (e.g., John D**, +1-***-***-1234, test@****.com).\n  - **MUST NOT**: Do not use personal information or provide it to third parties beyond the scope of the consented purpose.\n\n- **(P-3) Destruction**\n  - **MUST**: When the retention period expires or the processing purpose is achieved, personal information MUST be completely destroyed using an irreversible method.\n  - **MUST**: Establish a personal information destruction procedure and maintain a log of all destructions.\n\n## 6. Logging & Management\n- **(L-1) Log Recording**\n  - **MUST**: Logs for critical activities (e.g., login, access to personal information, privilege changes) MUST be securely retained for **at least one year**.\n  - **MUST**: Logs MUST be standardized and include at least the following: [Timestamp, User ID, Source IP Address, Request/Action, Success/Failure Status].\n",
      "writedAt": "2025-10-08T11:06:16.428Z"
    }
  ]
}